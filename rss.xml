<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom"
  version="2.0">
  <channel>
    <title><![CDATA[Satellytes]]></title>
    <description><![CDATA[Passionate experts that strive to build the best possible and above all right solution for our clients and customers.]]></description>
    <link>https://satellytes.com</link>
    <image>
      <url>https://satellytescommain21751-featrsshero.gtsb.io/sy-share-image.jpg</url>
      <title>Satellytes</title>
      <link>https://satellytes.com</link>
    </image>
    <generator>GatsbyJS</generator>
    <lastBuildDate>Mon, 20 Mar 2023 15:31:19 GMT</lastBuildDate>
    <item><title><![CDATA[Getting Started: Gatsby vs. Next.js vs. Remix]]></title><description><![CDATA[We developed a simple blog application in Gatsby, Next.js and Remix. Learn about the differences in the development process and the technical concepts behind these three frameworks.]]></description><link>
      https://satellytescommain21751-featrsshero.gtsb.io/blog/post/getting-started-gatsby-next-remix/</link><guid
        isPermaLink="false">
      https://satellytescommain21751-featrsshero.gtsb.io/blog/post/getting-started-gatsby-next-remix/</guid><enclosure url="https://images.ctfassets.net/54dnxp2417nl/5fCePk8aewwPIKCj9I5aTj/b652db31186358c555df2db14b65bbb7/gatsby-next-remix-hero.jpg" length="744356" type="image/jpeg" /><content:encoded>&lt;figure&gt;&lt;img
      src=&quot;https://satellytescommain21751-featrsshero.gtsb.io/_gatsby/image/38d8fb8fe42cc85f9ef7672ad7a1509a/4be445bf02c55418e404abd8f2a1a674/gatsby-next-remix-hero.jpg?eu=b965a93313f3141723d894748762f8a83251451c820181ab322bbc42cb54876fe7f747d5a2c9d067a861eda0d199e166d7a2139a73e1022fcc3b566dbad6d776ee24b2571bc2eddec636a42762574121209d08c1f7b94e6a027e475b18ba72dc49037acf19e9514efbb3d6279054f91100577033f743a32dc66dcab12c6a4866ae8d36c83dd7416caa78c1693dc0034c685001c075da4904e80859c13b66195fe18236d7272e827e0ca71ee489efffbaca51be8682a93e7748acf19f1985b899580ab24d708bd9ffc7574b7e511f6f5ae323fcfa4b90c358335fc96e851068a2da3132&amp;amp;a=w%3D1440%26h%3D760%26fm%3Djpg%26q%3D75&amp;amp;cd=2022-03-25T15%3A00%3A12.598Z&quot;
      alt=&quot;&quot;/&gt;&lt;figcaption&gt;&lt;a
      href=&quot;https://unsplash.com/photos/K59MPijxRh0&quot; target=&quot;_blank&quot;
      rel=&quot;nofollow noreferrer&quot;&gt;Image by Daniel
      Kudela&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt; &lt;p&gt;Before starting a React based
      project, the same question often arises: Which framework should be used? Of course, this
      question cannot be answered in a general way, since each framework has its advantages and
      disadvantages for specific use cases. Nevertheless, you can compare the frameworks, especially
      the concepts behind them.&lt;/p&gt;&lt;p&gt;That&amp;#39;s why we decided to develop a simple
      blog application in Gatsby, Next.js and Remix to compare the frameworks. This application can
      read data from markdown files, display them and create dynamic routes depending on them. This
      article will discuss the differences in the development process, as well as the basic
      technical concepts in the frameworks. The three versions of the comparison blog project were
      each deployed on Vercel or Netlify and have a public GitHub
      repository.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;üí° For simplification, style and images are
      not included in the examples. The detailed versions are available in the¬†&lt;a
      href=&quot;https://github.com/satellytes/blog-app-comparison&quot;&gt;GitHub
      repository&lt;/a&gt;¬†for the comparison blog
      project.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;b&gt;Blog app Gatsby
      Version:&lt;/b&gt;¬†&lt;a
      href=&quot;https://gatsby-comparison-blog.vercel.app/&quot;&gt;Preview&lt;/a&gt;¬†and¬†&lt;a
      href=&quot;https://github.com/satellytes/blog-app-comparison/tree/main/gatsby-comparison-blog&quot;&gt;Repository&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;b&gt;Blog
      app Next.js Version:&lt;/b&gt;¬†&lt;a
      href=&quot;https://next-js-comparison-blog.vercel.app/&quot;&gt;Preview&lt;/a&gt;¬†and¬†&lt;a
      href=&quot;https://github.com/satellytes/blog-app-comparison/tree/main/next-comparison-blog&quot;&gt;Repository&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;b&gt;Blog
      app Remix Version:&lt;/b&gt;¬†&lt;a
      href=&quot;https://remix-comparison-blog.netlify.app/&quot;&gt;Preview&lt;/a&gt;¬†and¬†&lt;a
      href=&quot;https://github.com/satellytes/blog-app-comparison/tree/main/remix-comparison-blog&quot;&gt;Repository&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img
      src=&quot;//images.ctfassets.net/54dnxp2417nl/2xeZZpwBzeh7Tb3OP9FjcU/9aa4661859436f6ab844ee909495b724/gastby-next-remix-screenshot-blog-overview.png&quot;
      alt=&quot;&quot;/&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Setting up
      a project&lt;/h2&gt;&lt;h4&gt;Gatsby&lt;/h4&gt;&lt;p&gt;To start a Gatsby project you have to
      run¬†&lt;code&gt;npx gatsby new&lt;/code&gt;. The setup process offers many individualization
      possibilities: Besides the project name and path, a CMS, a styling system (e.g.
      styled-components, emotion, ...), and additional features with other plugins (e.g. mdx
      support) can be added optionally. Gatsby has built-in out-of-the-box TypeScript support, so
      there is no distinction between TypeScript and JavaScript in the project
      setup.&lt;/p&gt;&lt;h4&gt;Next.js&lt;/h4&gt;&lt;p&gt;The command¬†&lt;code&gt;npx
      create-next-app@latest&lt;/code&gt;¬†can additionally be extended with the
      flag¬†&lt;code&gt;--ts&lt;/code&gt;¬†to add direct TypeScript support to a new Next.js project.
      The following setup process does not provide any customization options apart from the project
      name.&lt;/p&gt;&lt;h4&gt;Remix&lt;/h4&gt;&lt;p&gt;A Remix project can be set up with the
      command¬†&lt;code&gt;npx create-remix@latest&lt;/code&gt;. Then you can specify the project
      name, choose between different host options (e.g. Netlify or Vercel) and between TypeScript
      and JavaScript.&lt;/p&gt;&lt;h2&gt;Static Site Generation&lt;/h2&gt;&lt;p&gt;With static site
      generation (SSG), the HTML is generated once at built time and reused for each request. Of the
      three frameworks in this article, only Remix does not support
      SSG.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;‚ö°Ô∏è The options shown below for loading data only
      works in page/template components (they are bound to a certain url path or directory). To load
      data in components that do not have their own route, you must use other
      methods&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;b&gt;Gatsby&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;In
      general, there are two ways to create data-dependent pages in Gatsby. In our comparison blog
      project, pages are implicitly created using the file-based API. Alternatively, you can create
      pages manually using the¬†&lt;code&gt;create-pages&lt;/code&gt;¬†function
      in¬†&lt;code&gt;gatsby-node.js&lt;/code&gt;. In the following an example is given for both
      variants:&lt;/p&gt;&lt;p&gt;&lt;b&gt;With file-based API&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A static
      generated page with the file-based API consists of two parts: A GraphQL query and the actual
      React component (here¬†&lt;code&gt;BlogPost&lt;/code&gt;), which must be exported as default.
      In the GraphQL query, the required data is fetched. In this example, the Gatsby plugin¬†&lt;a
      href=&quot;https://www.gatsbyjs.com/plugins/gatsby-transformer-remark/&quot;&gt;gatsby-transformer-remark&lt;/a&gt;¬†is
      used to get the content of the corresponding markdown file. In the actual component, the
      results of the query can then be accessed via¬†&lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;
      &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{3,9-18} language-tsx{3,9-18}&quot;&gt;//
      pages/blog/{markdownRemark.frontmatter__path}.tsx

        const BlogPost = ({data}) =&amp;gt; {
        return (
        &amp;lt;div dangerouslySetInnerHTML={{__html: data.markdownRemark.html}}/&amp;gt;
        )
        }

        export const query = graphql`
        query ($id: String) {
        markdownRemark(id: {eq: $id}) {
        frontmatter {
        title
        path
        }
        html
        }
        }
        `

        export default BlogPost
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;p&gt;In our Gatsby blog project, we created a file
      named¬†&lt;code&gt;{markdownRemark.frontmatter__path}.tsx&lt;/code&gt;¬†to create a route for
      each blogpost. It is important that the filename consists of the¬†&lt;b&gt;path with the
      relevant key from the GraphQL query&lt;/b&gt;(here:¬†&lt;code&gt;path&lt;/code&gt;), which
      later determines the route of the page. In addition, the filename must be enclosed in curly
      brackets.&lt;/p&gt;&lt;p&gt;For example, the¬†&lt;code&gt;path&lt;/code&gt;¬†field in the
      markdown file of the first blogposts contains &amp;quot;first-blogpost&amp;quot;. The
      file-based API implicitly creates a route (&lt;a
      href=&quot;https://gatsby-comparison-blog.vercel.app/blog/first-blogpost&quot;&gt;https://gatsby-comparison-blog.vercel.app/blog/first-blogpost&lt;/a&gt;)
      and the remaining data (&lt;code&gt;html&lt;/code&gt;field in the GaphQL query) is loaded into
      the page.&lt;/p&gt;&lt;p&gt;&lt;b&gt;With create-pages API&lt;/b&gt;&lt;/p&gt;&lt;p&gt;To
      create a page with the create-pages API, a¬†&lt;code&gt;createPages&lt;/code&gt;¬†function must
      be defined in¬†&lt;code&gt;gatsby-node.js&lt;/code&gt;. In this function, the data is then
      loaded with a GraphQL query and passed into a template page. For each entry from the result of
      the¬†&lt;code&gt;query&lt;/code&gt;the¬†&lt;code&gt;createPage&lt;/code&gt;¬†action is called, in
      which¬†&lt;code&gt;path&lt;/code&gt;, template¬†&lt;code&gt;component&lt;/code&gt;,
      and¬†&lt;code&gt;context&lt;/code&gt;¬†are provided. An example from the¬†&lt;a
      href=&quot;https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#creating-pages-in-gatsby-nodejs&quot;&gt;Gatsby
      documentation&lt;/a&gt;¬†is given here:&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{7,8,11,37-45} language-tsx{7,8,11,37-45}&quot;&gt;//
      gatsby-node.js

        const path = require(&quot;path&quot;)

        // Implement the Gatsby API ‚ÄúcreatePages‚Äù. This is called once the
        // data layer is bootstrapped to let plugins create pages from data.
        exports.createPages = async ({ graphql, actions, reporter }) =&amp;gt; {
        const { createPage } = actions

        // Query for markdown nodes to use in creating pages.
        const result = await graphql(
        `
        {
        allMarkdownRemark(limit: 1000) {
        edges {
        node {
        frontmatter {
        path
        }
        }
        }
        }
        }
        `
        )

        // Handle errors
        if (result.errors) {
        reporter.panicOnBuild(`Error while running GraphQL query.`)
        return
        }

        // Create pages for each markdown file.
        const blogPostTemplate = path.resolve(`src/templates/blog-post.js`)
      result.data.allMarkdownRemark.edges.forEach(({ node }) =&amp;gt; {
        const path = node.frontmatter.path
        createPage({
        path,
        component: blogPostTemplate,
        // In your blog post template&apos;s graphql query, you can use pagePath
        // as a GraphQL variable to query for data from the markdown file.
        context: {
        pagePath: path,
        },
        })
        })
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;h4&gt;&lt;b&gt;Next.js&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;The roots of Next.js are in SSR, but
      relatively soon they also supported SSG. Thus, this framework supports both approaches
      well.&lt;/p&gt;&lt;p&gt;To create a static generated page in Next.js
      the¬†&lt;code&gt;async&lt;/code&gt;¬†function¬†&lt;code&gt;getStaticPaths&lt;/code&gt;¬†has to be
      exported. In the code snippet below, this function
      calls¬†&lt;code&gt;getAllPostPaths()&lt;/code&gt;, which returns a path for each markdown
      file.&lt;/p&gt;
        &lt;figure&gt;
        &lt;p&gt;```tsx{3,13-16,18,21-23, 27}
        // pages/blog/[path].tsx&lt;/p&gt;
        &lt;p&gt;export async function getStaticPaths() {
        // That&apos;s the data format we expect:
        // paths: [
        // {params: {path: &apos;first-blogpost&apos;}},
        // {params: {path: &apos;second-blogpost&apos;}},
        // ‚Ä¶
        // {params: {path: &apos;fifth-blogpost&apos;}}
        // ],
        const paths = getAllPostPaths()&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;return {
        paths,
        fallback: false
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;export async function getStaticProps({params}: { params: PostsData }) {
        const postData = await getPostData(params.path)
        return {
        props: {
        postData
        }
        }
        }&lt;/p&gt;
        &lt;p&gt;export default function Post({postData}: { postData: PostData }) {
        return (
        &lt;div dangerouslySetInnerHTML={{__html: postData.contentHtml}}/&gt;
        )
        }
        ```&lt;/p&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;p&gt;&lt;code&gt;getStaticPaths&lt;/code&gt;¬†must return an object with the
      keys:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;path:&lt;/code&gt; This key determines
      which path will be pre-rendered. In the in-code comment above the structure
      of¬†&lt;code&gt;path&lt;/code&gt;¬†is given as an
      example.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;fallback&lt;/code&gt;: You can set
      the value of fallback
      to¬†&lt;code&gt;true&lt;/code&gt;,¬†&lt;code&gt;false&lt;/code&gt;¬†or¬†&lt;code&gt;blocking&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;false
      &lt;/code&gt;‚Üí Any paths not returned by¬†&lt;code&gt;getStaticPaths&lt;/code&gt;¬†will end up
      in a¬†404 page&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;true&lt;/code&gt; ‚Üí On the
      first request to a not generated path, Next.js will serve a fallback version of the page,
      instead of a 404 page. The HTML and JSON of this path is now generated in the background and
      and then the JSON is sent to the requesting browser. Now the fallback page changes into the
      full page. Next.js will add this path to the pre-rendered pages in order to be able to provide
      the already generated page for further requests. This is useful if you have a page with a lot
      of static pages because then not all pages have to be generated at built time, which makes the
      built much faster.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;blocking &lt;/code&gt;‚Üí
      Same procedure as for¬†&lt;code&gt;fallback: true&lt;/code&gt;, except that there is no
      fallback while the HTML is being generated. There are only very special uses cases in which
      this makes sense, such as
      AMP.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Remember to name the file
      after the relevant key from the¬†&lt;code&gt;params&lt;/code&gt;¬†object with square brackets,
      in our case¬†&lt;code&gt;[path].tsx&lt;/code&gt;. As long as the two names match, you can
      choose it as you wish. To load the data for a blogpost the
      function¬†&lt;code&gt;getStaticProps&lt;/code&gt;¬†is needed. This function now
      receives¬†&lt;code&gt;{params}&lt;/code&gt;, which can be used to determine the path and the
      depending data. Finally, in the actual page component, the data can be accessed via props
      (here via¬†&lt;code&gt;{postData}&lt;/code&gt;). The source code above shows how we built our
      comparison blog project using SSG and the methods just
      described.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;üí° The object returned
      by¬†&lt;code&gt;getStaticProps&lt;/code&gt;¬†can include other keys
      besides¬†&lt;code&gt;props&lt;/code&gt;, such
      as¬†&lt;code&gt;revalidate&lt;/code&gt;.¬†&lt;code&gt;revalidate&lt;/code&gt;¬†is set
      to¬†&lt;code&gt;false&lt;/code&gt;¬†by default, but can also contain the amount in seconds after
      which a page re-generation can occur. In this way, individual static pages can be changed at a
      certain interval after being built. This is called¬†&lt;a
      href=&quot;https://vercel.com/docs/concepts/next.js/incremental-static-regeneration&quot;&gt;Incremental
      Static Regeneration (ISR)&lt;/a&gt;¬†and also known as
      &amp;quot;stale-while-revalidate&amp;quot;.&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;b&gt;Remix&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;Remix
      only supports server side rendering, but this need not be a disadvantage. This is because CDN
      with proper caching headers will always be fast, except for cold requests (e.g. the first
      request). If the backend is too slow on these cold requests, this is a problem from the
      backend, which should then be improved. Also, it should be assumed that cold requests are
      rare. If this is not the case, it is a business problem and not a technical
      problem.&lt;/p&gt;&lt;h2&gt;Server Side Rendering (SSR)&lt;/h2&gt;&lt;p&gt;With server side
      rendering (SSR), the HTML is built on each request. All three frameworks support SSR. Usually,
      you use SSR in combination with a CDN to improve performance and
      responsiveness.&lt;/p&gt;&lt;h4&gt;&lt;b&gt;Gatsby&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;Besides static
      site generation (SSG) you can also use server side rendering (SSR) for certain use cases in
      Gatsby since version 4. For this, the function¬†&lt;code&gt;getServerData&lt;/code&gt;¬†must be
      built into a page, in which the data is requested from the server. This data can then be
      accessed in the actual page component with¬†&lt;code&gt;serverData&lt;/code&gt;. In the
      following the example from the¬†&lt;a
      href=&quot;https://www.gatsbyjs.com/docs/how-to/rendering-options/using-server-side-rendering/&quot;&gt;Gatsby
      documentation&lt;/a&gt;¬†is considered:&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{5,14} language-tsx{5,14}&quot;&gt;// pages/ssr.js

        import * as React from &quot;react&quot;

        const SSRPage = ({ serverData }) =&amp;gt; (
        &amp;lt;main&amp;gt;
        &amp;lt;h1&amp;gt;SSR Page with Dogs&amp;lt;/h1&amp;gt;
        &amp;lt;img alt=&quot;Happy dog&quot; src={serverData.message} /&amp;gt;
      &amp;lt;/main&amp;gt;
        )

        export default SSRPage

        export async function getServerData() {
        try {
        const res = await fetch(`https://dog.ceo/api/breeds/image/random`)

        if (!res.ok) {
        throw new Error(`Response failed`)
        }

        return {
        props: await res.json(),
        }
        } catch (error) {
        return {
        status: 500,
        headers: {},
        props: {}
        }
        }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;h4&gt;&lt;b&gt;Next.js&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;To use SSR in Next.js you have to
      use¬†&lt;code&gt;getServerSideProps&lt;/code&gt;¬†instead
      of¬†&lt;code&gt;getStaticProps&lt;/code&gt;¬†in the SSG variant. This function must load the
      data and return it, too. The data can then be accessed in the page component (in the example
      via¬†&lt;code&gt;data&lt;/code&gt;). The following example shows a simple SSR implementation
      from the¬†&lt;a
      href=&quot;https://nextjs.org/docs/basic-features/pages#server-side-rendering&quot;&gt;Next.js
      documentation&lt;/a&gt;.&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{3,8} language-tsx{3,8}&quot;&gt;// pages/ssr.js

        function Page({ data }) {
        // Render data...
        }

        // This gets called on every request
        export async function getServerSideProps() {
        // Fetch data from external API
        const res = await fetch(`https://.../data`)
        const data = await res.json()

        // Pass data to the page via props
        return { props: { data } }
        }

        export default Page
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;h4&gt;&lt;b&gt;Remix&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;Remix has an
      exported¬†&lt;code&gt;loader&lt;/code&gt;¬†function in which the data (e.g. local markdown file)
      is loaded (similar to¬†&lt;code&gt;getStaticProps&lt;/code&gt;in Next.js).
      This¬†&lt;code&gt;loader&lt;/code&gt;¬†function can receive
      a¬†&lt;code&gt;{params}&lt;/code&gt;¬†object.¬†&lt;code&gt;{params}&lt;/code&gt;¬†can be used to
      access the path with¬†&lt;code&gt;params.slug&lt;/code&gt;¬†and load the corresponding data. If
      you use the¬†&lt;code&gt;params&lt;/code&gt;¬†object and want to build the route depending on
      the data, it is important to name your file with a¬†&lt;code&gt;$&lt;/code&gt;¬†character and
      the key of the pathname. So in our example, it is¬†&lt;code&gt;$slug.tsx&lt;/code&gt;. In the
      page component (here¬†&lt;code&gt;PostSlug&lt;/code&gt;) the data can then be accessed via
      the¬†&lt;code&gt;useLoader&lt;/code&gt;¬†hook.&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{3,9} language-tsx{3,9}&quot;&gt;// routes/blog/$slug.tsx
      export const loader: LoaderFunction = async ({params}) =&amp;gt; {
        invariant(params.slug, &quot;expected params.slug&quot;);
        return getPost(params.slug);
        };

        export default function PostSlug() {
        const post = useLoaderData();
        return (
        &amp;lt;div dangerouslySetInnerHTML={{ __html: post.html }} /&amp;gt;
        );
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;blockquote&gt;&lt;p&gt;üí° Other than Next.js and Gatsby, Remix can&amp;#39;t just return
      components from the SSR routes. Remix can also return other data, like images or PDF. This
      feature is called &amp;quot;Resource routes&amp;quot;. You can read more about this in
      the¬†&lt;a href=&quot;https://remix.run/docs/en/v1/guides/resource-routes&quot;&gt;official
      documentation&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;Adding Page
      Metadata&lt;/h2&gt;&lt;p&gt;The page header data, such as the html title, meta description and
      structural data like¬†&lt;a href=&quot;https://ogp.me/&quot;&gt;open graph&lt;/a&gt;¬†are
      especially important for SEO. In the following examples, some meta tags should be added to the
      pages. For this, each framework offers its own
      solution.&lt;/p&gt;&lt;h4&gt;&lt;b&gt;Gatsby&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;To add page metadata
      in Gatsby, the¬†&lt;code&gt;gatsby-plugin-react-helmet&lt;/code&gt;¬†and¬†&lt;code&gt;React
      Helmet&lt;/code&gt;¬†are recommended. Generally, Gatsby plugins are installed via a package
      manager and then have to be added to¬†&lt;code&gt;gatsby-config.js&lt;/code&gt;. So in our
      example blog we first had to run¬†&lt;code&gt;npm install gatsby-plugin-react-helmet
      react-helmet&lt;/code&gt;¬†and then add the plugin
      to¬†&lt;code&gt;gatsby-config.js&lt;/code&gt;:&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;jsx language-jsx&quot;&gt;// gatsby-config.js
        {
        plugins: [`gatsby-plugin-react-helmet`]
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;p&gt;After that, you can access the¬†&lt;code&gt;React Helmet&lt;/code&gt;¬†within the JSX
      of a component, like for example in the index page.&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{9-13} language-tsx{9-13}&quot;&gt;//
      pages/blog/index.tsx

        //...
        import { Helmet } from &quot;react-helmet&quot;

        const Index = () =&amp;gt; {
        return (
        &amp;lt;Layout&amp;gt;
        &amp;lt;Helmet&amp;gt;
        &amp;lt;title&amp;gt;Gatsby Blog&amp;lt;/title&amp;gt;
        &amp;lt;meta name=&quot;description&quot; content=&quot;A simple Gatsby blog
      application&quot; /&amp;gt;
        &amp;lt;meta property=&quot;og:image&quot;
      content=&quot;https://josiesshakeshack.com/logo.jpg&quot; /&amp;gt;
        &amp;lt;/Helmet&amp;gt;
        {/*content goes here*/}
        &amp;lt;/Layout&amp;gt;
        );
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;h4&gt;&lt;b&gt;Next.js&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;Next.js provides
      a¬†&lt;code&gt;head&lt;/code&gt;¬†component that can be built into any page to add
      metadata.&lt;/p&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{9-13} language-tsx{9-13}&quot;&gt;//
      pages/blog/index.tsx

        //...
        import Head from &quot;next/head&quot;;

        const Home: NextPage = () =&amp;gt; {
        return (
        &amp;lt;Layout&amp;gt;
        &amp;lt;Head&amp;gt;
        &amp;lt;title&amp;gt;Next.js Blog&amp;lt;/title&amp;gt;
        &amp;lt;meta name=&quot;description&quot; content=&quot;A simple Next.js blog
      application&quot; /&amp;gt;
        &amp;lt;meta property=&quot;og:image&quot;
      content=&quot;https://josiesshakeshack.com/logo.jpg&quot; /&amp;gt;
        &amp;lt;/Head&amp;gt;
        {/*content goes here*/}
        &amp;lt;/Layout&amp;gt;
        );
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;h4&gt;&lt;b&gt;Remix&lt;/b&gt;&lt;/h4&gt;&lt;p&gt;To add metadata to Remix projects you
      have to add the¬†&lt;code&gt;&amp;lt;Meta /&amp;gt;&lt;/code&gt;¬†component in
      the¬†&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;¬†part of¬†&lt;code&gt;root.tsx&lt;/code&gt;.
      After that, a¬†&lt;code&gt;meta&lt;/code&gt;¬†function can be exported to other pages. This must
      return an object with all relevant metadata.&lt;/p&gt;&lt;p&gt;The meta function automatically
      distinguishes between three different meta data
      categories:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;title&lt;/code&gt; renders
      a¬†&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;¬†tag&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;OpenGraph&lt;/code&gt;
      tags (e.g.¬†&lt;code&gt;&amp;quot;og:image‚Äù&lt;/code&gt;) will render¬†&lt;code&gt;&amp;lt;meta
      property content&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Everything else
      renders &lt;code&gt;&amp;lt;meta name={key}
      content={value}/&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
        &lt;figure&gt;
        &lt;pre&gt;&lt;code class=&quot;tsx{6-17} language-tsx{6-17}&quot;&gt;//
      routes/blog/index.tsx

        //...
        import {MetaFunction} from &quot;remix&quot;;

        export const meta: MetaFunction = () =&amp;gt; {
        return {
        // &amp;lt;title&amp;gt;Remix Blog&amp;lt;/title&amp;gt;
        title: &quot;Remix Blog&quot;,

        // &amp;lt;meta name=&quot;description&quot; content=&quot;A simple Remix blog
      application&quot;&amp;gt;
        description: &quot;A simple Remix blog application&quot;,

        // &amp;lt;meta property=&quot;og:image&quot;
      content=&quot;https://josiesshakeshack.com/logo.jpg&quot;&amp;gt;
        &quot;og:image&quot;: &quot;https://josiesshakeshack.com/logo.jpg&quot;
        };
        };

        export default function Index() {
        return (
        &amp;lt;Layout&amp;gt;
        {/*content goes here*/}
        &amp;lt;/Layout&amp;gt;
        );
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;figcaption&gt;&lt;/figcaption&gt;
        &lt;/figure&gt;
        &lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Next.js and Gatsby have quite a lot in common as
      they support both SSR and SSG. The differences are more in detail such as incremental static
      generation in Next.js or incremental builds in Gatsby. However, it is noticeable that SSR in
      Gatsby is still a relatively new and not as developed feature as it is in
      Next.js.&lt;/p&gt;&lt;p&gt;Remix is the newest of these three frameworks and only supports
      SSR. However, with the appropriate headers, SSG is approached very closely, which means that
      it may be possible to completely replace real SSG. The developers of Remix have published an
      interesting¬†&lt;a
      href=&quot;https://www.youtube.com/watch?v=bfLFHp7Sbkg&quot;&gt;video&lt;/a&gt;¬†and¬†&lt;a
      href=&quot;https://remix.run/blog/remix-vs-next&quot;&gt;blog post&lt;/a&gt;¬†about
      this.&lt;/p&gt;&lt;p&gt;Thanks for reading my article about the different frameworks. I hope
      you learned something about the basic concepts behind Gatsby, Next.js and Remix. As I
      mentioned in the introduction, there is no clear answer to the question &amp;quot;Which
      framework should be used in my next project?&amp;quot; because every project has its
      individual requirements.&lt;/p&gt;</content:encoded></item>
  </channel>
</rss>
